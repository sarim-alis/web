"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGetAxisFilters = exports.createAxisFilterMapper = void 0;
var _internals = require("@mui/x-charts/internals");
const createAxisFilterMapper = ({
  zoomData,
  extremumGetter,
  formattedSeries,
  direction
}) => (axis, axisIndex) => {
  if (typeof axis.zoom !== 'object' || axis.zoom.filterMode !== 'discard') {
    return null;
  }
  const zoom = zoomData?.find(({
    axisId
  }) => axisId === axis.id);
  if (zoom === undefined || zoom.start <= 0 && zoom.end >= 100) {
    // No zoom, or zoom with all data visible
    return null;
  }
  let extremums = [];
  const scaleType = axis.scaleType;
  if (scaleType === 'point' || scaleType === 'band') {
    extremums = [0, (axis.data?.length ?? 1) - 1];
  } else {
    extremums = (0, _internals.getAxisExtremum)(axis, extremumGetter, axisIndex, formattedSeries);
  }
  let min;
  let max;

  // @ts-expect-error The function defaults to linear scale if the scaleType is not recognized.
  [min, max] = (0, _internals.getScale)(scaleType, extremums, [0, 100]).nice().domain();
  min = min instanceof Date ? min.getTime() : min;
  max = max instanceof Date ? max.getTime() : max;
  const minVal = min + zoom.start * (max - min) / 100;
  const maxVal = min + zoom.end * (max - min) / 100;
  return (value, dataIndex) => {
    const val = value[direction] ?? axis.data?.[dataIndex];
    if (val == null) {
      // If the value does not exist because of missing data point, or out of range index, we just ignore.
      return true;
    }
    if (axis.scaleType === 'point' || axis.scaleType === 'band' || typeof val === 'string') {
      return dataIndex >= minVal && dataIndex <= maxVal;
    }
    return val >= minVal && val <= maxVal;
  };
};
exports.createAxisFilterMapper = createAxisFilterMapper;
const createGetAxisFilters = filters => ({
  currentAxisId,
  seriesXAxisId,
  seriesYAxisId,
  isDefaultAxis
}) => {
  return (value, dataIndex) => {
    const axisId = currentAxisId === seriesXAxisId ? seriesYAxisId : seriesXAxisId;
    if (!axisId || isDefaultAxis) {
      return Object.values(filters ?? {})[0]?.(value, dataIndex) ?? true;
    }
    const data = [seriesYAxisId, seriesXAxisId].filter(id => id !== currentAxisId).map(id => filters[id ?? '']).filter(_internals.isDefined);
    return data.every(f => f(value, dataIndex));
  };
};
exports.createGetAxisFilters = createGetAxisFilters;